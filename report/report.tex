\documentclass{article}

\usepackage{verbatim}

\newcommand{\symb}{{symbols}}
\newcommand{\signature}{{sign}}
\newcommand{\comp}{{compilation}}

\begin{document}

    This report is, at the moment, a draft reminding us the different steps we
    considered (even trivially false ones) to reach our conclusions.

   \section{Deciding version of a library used by a program.} 

   \subsection{First try to define the problem.}

   Let $\mathcal{D}$ a database of versionned libs to be set of $n$ tuples such that:
    \[ \mathcal{D} = \{ (n_i, v_i, s_i, \mathcal{B}_i) \}_{\{i \in \{1 \dots n\}\}}  \]
    where $n_i$ is the library name, $v_i$ a the library version, $s_i$ the source
    code of the library, and $\mathcal{B}_i$ is the set of binary compiled
    from the source code $s_i$. 

    Let $L$ be a binary code of a library.

    We want to find a function $V(L,D)$ such that if $L$ is compiled from a
    source code $C$ and $(N, V, C, \_) \in \mathcal{D}$ then $V(L,D)$ returns
    $(N,V)$.

    \subsection{Manual methods to look for a library version.}
    Finding some version numbers inside the binary file as data.
    It works for openssl but not with zlib.
    Issue, it does not seem to be a standard practice.

    Looking for symbols in the file. 
    Hypothesis: It returns the calls to the libs.
    Issue, it does not really help to get the version.

    Looking for version info function in the symbols of the file. Would
    probably work for zlib if we understood how this function works.
    Example: In the Good..apk, a library calls or includes the function zlibVersion statically. This function returns the version number, but we were not able to retrieve it in the binary code of the function.
    
    Semantically checking last pushed versions of functions seems to be an
    interesting approach, we may have a look at it later.

    \subsection{Naive approach}\label{naive-notations}
    We could simply try if there exists $(N, V, \_, \{\dots, B, \dots\} \in
    \mathcal{D}$ such that $L = B$.

    But after some tests and look on the \verb|diff| of these binaries we
    concluded that major differences can come from the compiling options,
    compilers and related stuff.

    Question: can we generate all possible compiled binaries in our database ? 
    
    Answer: It would certainly be a bad idea\dots

    \subsection{Second approach}\label{approach-sign}
    Can we find a smarter way to compute $V(L,D)$ ?

    We could find a function $\signature$ such that $\signature(L) =
    \signature(B)$.

    We plan to reuse a signature function designed for malware.

    Expected issues: since a new version is not that different from the former
    one, we do not know if we will obtain good results. In the binary, differences between two versions may not be more important than differences between two different compilers, or optimisations.

    \subsection{Third approach}
    
    %We conclude in the previous part that it is not relevant to compare  binaries that are compiled differently. 

    We will now work on distinguishing versions with the differences brought
    by version patches.

    % In the following we consider the same notations as in subsection~\ref{naive-notations}.

    Let $C$ be the source code of the version $V$ of library $N$,
    i.e. $C$ could be OpenSSL library sources, $V$ the version of $C$ which
    is $1.0.0$ and $N$ could be the name of the library, here it would be OpenSSL.

    Let $\mathcal{D}$ be a database containing several $3$-tuple $(C,V,N)$, and $P(C, C')$ be the $c$ code upgrading $C$ to $C'$

    Checking if the $c$ is handled by $L$ is not trivial. Trying method based on simplified CFG to check similarities lead to the same issues as in subsection~\ref{approach-sign}. Hence, we want to check
    if the behaviour of patched function differs.

    Basically we will check if the patched functions generate the same traces
    as $L$ functions.


    %TODO : comparer les signatures des fonctions pour discriminer des
    %librairies

    So we shifted the problem to a sub-problem that can decide the version of
    $L$, which is: Is the function $f \in L$ is up to date considering $C$.

    We will first consider dynamically linked libraries.
    
    Different major versions have different signature functions. For example one function $f$ from OpenSSL 1.0.* and the same function $f$ from OpenSSL 1.1.* have different arguments, then it is possible to eliminate a lot of versions of OpenSSL for the library $L$. The limitation of this trick is that all the function in two different minor versions as OpenSSL 1.0.2.h and OpenSSL 1.0.2.j have the same signatures.

    Procedure to check if $f \in L$, considering that $f \in \symb(C)$
    First we automatically generate a $c$ code $P$ calling $f$ with random
    parameters and catching/returning its behaviour. 
    Second, we compile $P'$ dynamically linking $\comp(C)$ according to the
    headers of $C$, we will note this compiled program $\comp(P')$. 
    Third, we compile $P$ dynamically linking $L$ according to the headers of
    $C$, we will note this compiled program $\comp(P)$. 
    Last, we check the similarities of returns of $\comp(P)$ and $\comp(P')$
    to decide.


    \subsection{Expected optimizations}
    We do not expect good result using only random testing. Hence, we will aid
    testing by an analysis of the patch, finding specific traces to
    distinguish when it is applied, we have yet to define details about this
    part. 
    Or we can do something similar to the concolic approach.
    

    
    \subsection{Other tools}

		\subsubsection{Coccinelle} 
			Coccinelle uses static analysis to find pattern in C source code. Using a known bug as a pattern leads to discover if the patch was applied or not. It seems not to be interesting in our case, because we deal with binaries.
		\subsubsection{n-gram}

\end{document}
