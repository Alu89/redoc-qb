\documentclass{article}

\usepackage{verbatim}

\newcommand{\symb}{{symbols}}
\newcommand{\signature}{{sign}}
\newcommand{\comp}{{compilation}}

\begin{document}

    This report is, at the moment, a draft reminding us the different steps we
    considered (even trivially false ones) to reach our conclusions.

   \section{Deciding version of a library used by a program.} 

   \subsection{First try to define the problem.}

   Let $\mathcal{D}$ a database of versionned libs to be set of $n$ tuples such that:
    \[ \mathcal{D} = \{ (n_i, v_i, s_i, \mathcal{B}_i) \}_{\{i \in \{1 \dots n\}\}}  \]
    where $n_i$ is the library name, $v_i$ a the library version, $s_i$ the source
    code of the library, and $\mathcal{B}_i$ is the set of binary compiled
    from the source code $s_i$. 

    Let $L$ be a binary code of a library.

    We want to find a function $V(L,D)$ such that if $L$ is compiled from a
    source code $C$ and $(N, V, C, \_) \in \mathcal{D}$ then $V(L,D)$ returns
    $(N,V)$.

    \subsection{Manual methods to look for a library version.}
    Finding some version numbers inside the binary file as data.
    It works for openssl but not with zlib.
    Issue, it does not seem to be a standard practice.

    Looking for symbols in the file. 
    Hypothesis: It returns the calls to the libs.
    Issue, it does not really help to get the version.

    Looking for version info function in the symbols of the file. Would
    probably work for zlib if we understood how this function works.
    Example: In the Good..apk, a library calls or includes the function zlibVersion statically. This function returns the version number, but we were not able to retrieve it in the binary code of the function.
    
    Semantically checking last pushed versions of functions seems to be an
    interesting approach, we may have a look at it later.

    \subsection{Naive approach}\label{naive-notations}
    We could simply try if there exists $(N, V, \_, \{\dots, B, \dots\} \in
    \mathcal{D}$ such that $L = B$.

    But after some tests and look on the \verb|diff| of these binaries we
    concluded that major differences can come from the compiling options,
    compilers and related stuff.

    Question: can we generate all possible compiled binaries in our database ? 
    
    Answer: It would certainly be a bad idea\dots

    \subsection{Second approach}\label{approach-sign}
    Can we find a smarter way to compute $V(L,D)$ ?

    We could find a function $\signature$ such that $\signature(L) =
    \signature(B)$.

    We plan to reuse a signature function designed for malware.

    Expected issues: since a new version is not that different from the former
    one, we do not know if we will obtain good results.

    \subsection{Third approach}
    We conclude in the previous part that it is not relevant to compare
    binaries that are compiled differently. 

    We will now work on distinguishing versions with the differences brought
    by version patches.

    % In the following we consider the same notations as in subsection~\ref{naive-notations}.

    We have that $C$ is the source code of the version $V$ of library $N$,
    i.e. $C$ could be openssl library sources, $V$ the major version $C'$ wich
    is $1.0.0$ and
    $N$ would be the name of the library, here it would be Openssl.

    We have that $(C,V,N) \in \mathcal{D}$.

    To check if $L$ is the library $N$ at the version $V$ we will expect the
    following.

    Let $P(C',C,V,N)$ be the $c$ code patching version from that major one to
    the $V$ one.

    Checking if the $c$ is handled by $L$ is not an easy problem. If we try
    method based on simplified CFG to check similarities we would have the
    same issues as in subsection~\ref{approach-sign}. Hence, we want to check
    if the behaviour of patched function differs.

    Basically we will check if the patched functions generate the same traces
    as $L$ functions.

    %TODO : comparer les signatures des fonctions pour discriminer des
    %librairies

    So we shifted the problem to a sub-problem that can decide the version of
    $L$, which is: Is the function $f \in L$ is up to date considering $C$.

    We will first consider dynamically linked libraries.

    Procedure to check if $f \in L$, considering that $f \in \symb(C)$
    First we automatically generate a $c$ code $P$ calling $f$ with random
    parameters and catching/returning its behaviour. 
    Second, we compile $P'$ dynamically linking $\comp(C)$ according to the
    headers of $C$, we will note this compiled program $\comp(P')$. 
    Third, we compile $P$ dynamically linking $L$ according to the headers of
    $C$, we will note this compiled program $\comp(P)$. 
    Last, we check the similarities of returns of $\comp(P)$ and $\comp(P')$
    to decide.

    \subsection{Expected optimizations}
    We do not expect good result using only random testing. Hence, we will aid
    testing by an analysis of the patch, finding specific traces to
    distinguish when it is applied, we have yet to define details about this
    part. 
    Or we can do something similar to the concolic approach.

\end{document}
